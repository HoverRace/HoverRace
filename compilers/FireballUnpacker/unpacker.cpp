// main.cpp

// This utility takes a .dat file (like ObjFac1.dat) 
// and unpacks it into all of the components it was 
// created from.

// This program is Win32 dependent, but that does not matter since this utility
// only serves to unpack ObjFac1.dat (and maybe it will be useful for some other
// files), which are already Win32 only

// Usage:
// unpacker InputFile

#include "StdAfx.h"

#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <math.h>

#include <vfw.h>
#include <mmreg.h>

#include "../../engine/ObjFacTools/ResourceLib.h"
#include "../../engine/ColorTools/ColorTools.h"
#include "../../engine/Util/Config.h"
#include "ResActorExt.h"
#include "ResSpriteExt.h"
#include "ResShortSoundExt.h"
#include "ResContinuousSoundExt.h"

using namespace std;

static void usage();

int main(int pArgc, const char **pArgs) {
	if(pArgc < 2 || pArgc > 3) {
		usage();
		exit(1);
	}

	MR_ColorTools::Init();

	printf("Fireball Object Factory unpacker\n");
	bool eightbitcolor = false;
	int objarg = 0;

	if(pArgc == 2) {
		objarg = 1;
		eightbitcolor = false;
	} else {
		if(strcmp(pArgs[1], "-8") == 0) {
			eightbitcolor = true;
			objarg = 2;
		} else {
			printf("Unknown parameter %s or too many params\n", pArgs[1]);
			exit(1);
		}
	}

	char ofilename[255];
	sprintf(ofilename, "%s.in", pArgs[1]);

	filebuf obuf;
	obuf.open(ofilename, ios::out);
	ostream oout(&obuf);

	oout << "// Automatically generated by Fireball object factory unpacker\n";

	MR_ResourceLib lib(pArgs[objarg]);

	/* since MR_ResourceLib doesn't give us a way to know how many of each object we 
	 * have... we will exhaustively try every possible key */
	// takes too long
	//for(int i = INT_MIN; i < INT_MAX; i++) {
	for(int i = 0; i < 32768; i++) {
		const MR_ResBitmap			*curBitmap = lib.GetBitmap(i);
		const MR_ResActor			*curActor  = lib.GetActor(i);
		const MR_ResSprite			*curSprite = lib.GetSprite(i);
		const MR_ResShortSound		*curSSound = lib.GetShortSound(i);
		const MR_ResContinuousSound	*curCSound = lib.GetContinuousSound(i);

		if(curBitmap != NULL) {
			/* take our bitmap and write it to file */
			char filename[16];
			sprintf(filename, "%d.bmp", i);
			printf("Extracting bitmap %d\n", i);

			HANDLE file = CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(!file) {
				printf("Fatal: error opening file %s\n", filename);
				exit(1);
			}

			/* thanks to http://sarathc.wordpress.com/2007/03/14/how-to-save-bitmap-to-file/ */
			BITMAPINFOHEADER bih = {0};
			BITMAPFILEHEADER bfh = {0};

			bih.biSize = sizeof(BITMAPINFOHEADER);
			
			if(eightbitcolor)
				bih.biBitCount = 8;
			else
				bih.biBitCount = 24;

			bih.biClrImportant = 0;
			bih.biClrUsed = 0;
			bih.biCompression = BI_RGB;
			bih.biHeight = curBitmap->GetMaxYRes();
			bih.biWidth = curBitmap->GetMaxXRes();
			bih.biPlanes = 1;
			bih.biSizeImage = bih.biHeight * bih.biWidth * (bih.biBitCount / 8);

			bfh.bfType = 0x4D42;
			bfh.bfOffBits = sizeof(BITMAPINFOHEADER) + sizeof(BITMAPFILEHEADER);
			bfh.bfSize = bih.biSizeImage + bfh.bfOffBits;

			MR_UInt8 *origpixels = curBitmap->GetBuffer(0);
			MR_UInt8 *newpixels = (MR_UInt8 *) malloc(bih.biSizeImage);
				
			for(int j = 0; j < (bih.biHeight * bih.biWidth); j++) {
				if(eightbitcolor) {
					//newpixels[j] = origpixels[j];
					newpixels[(((j % bih.biWidth)) * bih.biHeight + 
						(int) (floor((double) j / bih.biWidth)))] = (MR_UInt8) origpixels[j];
				} else {
					// convert to 24-bit color
					int r, g, b;

					// I have no idea why this offset of 4 is required
					MR_ColorTools::GetIntComponents(origpixels[j] - MR_RESERVED_COLORS - 4, r, g, b);

					// need to rotate 90 degrees:
					int basePixel = 3 * (((j % bih.biWidth)) * bih.biHeight + 
						(int) (floor((double) j / bih.biWidth)));
					//int basePixel = 3 * j;

					newpixels[basePixel] = (MR_UInt8) b;
					newpixels[basePixel + 1] = (MR_UInt8) g;
					newpixels[basePixel + 2] = (MR_UInt8) r;
				}
			}

			// we rotated
			LONG tmp = bih.biHeight;
			bih.biHeight = bih.biWidth;
			bih.biWidth = tmp;

			DWORD written = 0;
			WriteFile(file, &bfh, sizeof(bfh), &written, NULL);
			WriteFile(file, &bih, sizeof(bih), &written, NULL);

			WriteFile(file, newpixels, bih.biSizeImage, &written, NULL);

			CloseHandle(file);

			// add to output file
			char oline[1024];
			sprintf(oline, "BITMAP %s %d %f %f %d\n", filename, curBitmap->GetResourceId(),
				((float) curBitmap->GetWidth()) / 1000.0, ((float) curBitmap->GetHeight()) / 1000.0,
				(curBitmap->GetNbSubBitmap() == 1) ? 0 : 1);
			oout << oline;
		}

		if(curActor != NULL) {
			printf("Extracting actor %d\n", i);

			// curActor is technically not a ResActorExt but this works anyway
			ResActorExt *ext = (ResActorExt *) curActor;

			char filename[16];
			sprintf(filename, "%d.msh", i);

			filebuf fbuf;
			fbuf.open(filename, ios::out);
			ostream out(&fbuf);

			for(int j = 0; j < ext->GetSequenceCount(); j++) {
				out << "SEQUENCE\n";

				for(int k = 0; k < ext->GetFrameCount(j); k++) {
					out << "FRAME\n";

					for(int l = 0; l < ext->GetComponentCount(j, k); l++) {
						MR_3DCoordinate *vertexList = ext->GetVertexList(j, k, l);

						if(vertexList != NULL) {
							out << "PATCH\n";
							char buffer[200];
							sprintf(buffer, "%d %d\n\0", ext->GetPatchURes(j, k, l), ext->GetPatchVRes(j, k, l));

							out << buffer;

							for(int m = 0; m < ext->GetVertexCount(j, k, l); m++) {
								sprintf(buffer, "%d %d %d\n\0", vertexList[m].mX, vertexList[m].mY, vertexList[m].mZ);

								out << buffer;
							}

							sprintf(buffer, "%d \n\0", ext->GetPatchBitmapId(j, k, l));
							out << buffer;

							out << "\n";
						}
					}
				}
			}

			char oline[1024];
			sprintf(oline, "ACTOR %s %d\n", filename, ext->GetResourceId());
			oout << oline;
		}

		if(curSprite != NULL) {
			printf("Extracting sprite %d\n", i);

			ResSpriteExt *ext = (ResSpriteExt *) curSprite;

			/* take our bitmap and write it to file */
			char filename[22];
			sprintf(filename, "%d.sprite.bmp", i);
			printf("Extracting sprite %d\n", i);

			HANDLE file = CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(!file) {
				printf("Fatal: error opening file %s\n", filename);
				exit(1);
			}

			/* thanks to http://sarathc.wordpress.com/2007/03/14/how-to-save-bitmap-to-file/ */
			BITMAPINFOHEADER bih = {0};
			BITMAPFILEHEADER bfh = {0};

			bih.biSize = sizeof(BITMAPINFOHEADER);
			
			if(eightbitcolor)
				bih.biBitCount = 8;
			else
				bih.biBitCount = 24;
			
			bih.biClrImportant = 0;
			bih.biClrUsed = 0;
			bih.biCompression = BI_RGB;
			bih.biHeight = ext->GetTotalHeight();
			bih.biWidth = ext->GetItemWidth();
			bih.biPlanes = 1;
			bih.biSizeImage = bih.biHeight * bih.biWidth * (bih.biBitCount / 8);

			bfh.bfType = 0x4D42;
			bfh.bfOffBits = sizeof(BITMAPINFOHEADER) + sizeof(BITMAPFILEHEADER);
			bfh.bfSize = bih.biSizeImage + bfh.bfOffBits;

			DWORD written = 0;
			WriteFile(file, &bfh, sizeof(bfh), &written, NULL);
			WriteFile(file, &bih, sizeof(bih), &written, NULL);

			MR_UInt8 *origpixels = ext->GetData();
			MR_UInt8 *newpixels = (MR_UInt8 *) malloc(bih.biSizeImage);
			for(int j = 0; j < (bih.biHeight * bih.biWidth); j++) {
				if(eightbitcolor) {
					//newpixels[((bih.biHeight * bih.biWidth - (j + 1)) -
					//	((bih.biHeight * bih.biWidth - (j + 1)) % bih.biWidth) +
					//	(bih.biWidth - ((bih.biHeight * bih.biWidth - (j + 1)) % bih.biWidth)))] = origpixels[j];
					newpixels[j] = origpixels[j];
				} else {
					// convert to 24-bit color
					int r, g, b;
					// I have no idea why this offset of 4 is required
					MR_ColorTools::GetIntComponents(origpixels[j] - MR_RESERVED_COLORS - 4, r, g, b);

					// pixels need to be inverted
					//int basePixel = 3 * ((bih.biHeight * bih.biWidth - (j + 1)) - 
					//	((bih.biHeight * bih.biWidth - (j + 1)) % bih.biWidth) + 
					//	(bih.biWidth - ((bih.biHeight * bih.biWidth - (j + 1)) % bih.biWidth)));
					int basePixel = 3 * j;

					newpixels[basePixel] = (MR_UInt8) b;
					newpixels[basePixel + 1] = (MR_UInt8) g;
					newpixels[basePixel + 2] = (MR_UInt8) r;
				}
			}

			WriteFile(file, newpixels, bih.biSizeImage, &written, NULL);

			CloseHandle(file);

			char oline[1024];
			int nb = ext->GetNbItem();
			sprintf(oline, "SPRITE %s %d %d\n", filename, ext->GetResourceId(), nb);
			oout << oline;
		}

		if(curSSound != NULL) {
			printf("Extracting short sound %d\n", i);

			ResShortSoundExt *ext = (ResShortSoundExt *) curSSound;

			char filename[21];
			sprintf(filename, "%d.short.wav", i);

			FILE *fwav = fopen(filename, "wb");

			if(fwav == NULL) {
				printf("Fatal: error opening file %s\n", filename);
				exit(1);
			}

			/**
			 * RIFF format (I know a lot about this!  Hooray!):
			 * 
			 * RIFF			4 bytes
			 * length		4 bytes
			 * WAVE			4 bytes
			 * fmt			4 bytes (chunk header)
			 * length		4 bytes	(length of chunk -- sizeof(WAVEHEADER))
			 * wave header			WAVEHEADEREX *
			 * data			4 bytes (chunk header)
			 * length		4 bytes (length of chunk)
			 * sound data	....
			 */

			/* for some reason Richard embedded the length and WAVEHEADEREX into the data,
				which makes our lives easier! */
			char *ptr = ext->GetData();
			// not necessary
			unsigned long totalDatalen = ext->GetDataLength() - sizeof(MR_UInt32) - sizeof(WAVEFORMATEX) + 38;

			unsigned long datalen = (unsigned long) ((MR_UInt32) *ptr);
			ptr += sizeof(MR_UInt32);
			// but datalen is wrong
			datalen = totalDatalen - 38;

			WAVEFORMATEX *hdr = ((WAVEFORMATEX *) ptr);
			ptr += sizeof(WAVEFORMATEX);
			// ptr now points at data, length of which is datalen

			//fwrite(data, bytes to be written, number of elements, fp)

			char riff[5] = "RIFF";
			fwrite(riff, sizeof(char), 4, fwav);
			//unsigned long totalDatalen = datalen + 36;
			fwrite(&totalDatalen, sizeof(unsigned long), 1, fwav);
			
			char wave[5] = "WAVE";
			fwrite(wave, sizeof(char), 4, fwav);

			char fmt[5] = "fmt ";
			fwrite(fmt, sizeof(char), 4, fwav);

			unsigned long chunkheadersize = sizeof(WAVEFORMATEX);
			fwrite(&chunkheadersize, sizeof(unsigned long), 1, fwav);
			fwrite(hdr, sizeof(WAVEFORMATEX), 1, fwav);

			char data[5] = "data";
			fwrite(data, sizeof(char), 4, fwav);

			fwrite(&datalen, sizeof(unsigned long), 1, fwav);

			fwrite(ptr, sizeof(char), datalen, fwav);

			fclose(fwav);

			char oline[1024];
			int nb = ext->GetNbCopy();
			sprintf(oline, "SHORT_SOUND %s %d %d\n", filename, ext->GetResourceId(), nb);
			oout << oline;
		}

		if(curCSound != NULL) {
			printf("Extracting continuous sound %d\n", i);

			ResContinuousSoundExt *ext = (ResContinuousSoundExt *) curCSound;

			char filename[20];
			sprintf(filename, "%d.cont.wav", i);

			FILE *fwav = fopen(filename, "wb");

			if(fwav == NULL) {
				printf("Fatal: error opening file %s\n", filename);
				exit(1);
			}

			/**
			 * RIFF format (I know a lot about this!  Hooray!):
			 * 
			 * RIFF			4 bytes
			 * length		4 bytes
			 * WAVE			4 bytes
			 * fmt			4 bytes (chunk header)
			 * length		4 bytes	(length of chunk -- sizeof(WAVEHEADER))
			 * wave header			WAVEHEADEREX *
			 * data			4 bytes (chunk header)
			 * length		4 bytes (length of chunk)
			 * sound data	....
			 */

			/* for some reason Richard embedded the length and WAVEHEADEREX into the data,
				which makes our lives easier! */
			char *ptr = ext->GetData();
			unsigned long totalDatalen = ext->GetDataLength() - sizeof(MR_UInt32) - sizeof(WAVEFORMATEX) + 38;

			//unsigned long datalen = (unsigned long) ((MR_UInt32) *ptr);
			unsigned long datalen = totalDatalen - 38;
			ptr += sizeof(MR_UInt32);

			WAVEFORMATEX *hdr = ((WAVEFORMATEX *) ptr);
			ptr += sizeof(WAVEFORMATEX);
			// ptr now points at data, length of which is datalen

			//fwrite(data, bytes to be written, number of elements, fp)

			char riff[5] = "RIFF";
			fwrite(riff, sizeof(char), 4, fwav);
			//unsigned long totalDatalen = datalen + 36;
			fwrite(&totalDatalen, sizeof(unsigned long), 1, fwav);
			
			char wave[5] = "WAVE";
			fwrite(wave, sizeof(char), 4, fwav);

			char fmt[5] = "fmt ";
			fwrite(fmt, sizeof(char), 4, fwav);

			unsigned long chunkheadersize = sizeof(WAVEFORMATEX);
			fwrite(&chunkheadersize, sizeof(unsigned long), 1, fwav);
			fwrite(hdr, sizeof(WAVEFORMATEX), 1, fwav);

			char data[5] = "data";
			fwrite(data, sizeof(char), 4, fwav);

			fwrite(&datalen, sizeof(unsigned long), 1, fwav);

			for(unsigned long i = 0; i < datalen - (datalen % 256); i += 256)
				fwrite((ptr + i), sizeof(char), 256, fwav);
			for(int i = 0; i < datalen % 256; i++)
				fwrite((ptr + (datalen - (datalen % 256)) + i), sizeof(char), 1, fwav);

			fclose(fwav);

			char oline[1024];
			int nb = ext->GetNbCopy();
			sprintf(oline, "CONT_SOUND %s %d %d\n", filename, ext->GetResourceId(), nb);
			oout << oline;
		}
	}

	printf("Completed\n");
}

static void usage() {
	fprintf(stderr, "unpacker [-8] <InputFile>\n  -8 extracts bitmaps in 8-bit color, with the original HR palette\n");
}