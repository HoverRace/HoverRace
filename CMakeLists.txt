
cmake_minimum_required(VERSION 2.8)
if(POLICY CMP0054)
	cmake_policy(SET CMP0054 OLD)
endif()

project(hoverrace CXX)

set(HR_APP_VERSION_MAJOR 2)
set(HR_APP_VERSION_MINOR 0)
set(HR_APP_VERSION_PATCH 0)
set(HR_APP_VERSION_BUILD 0 CACHE STRING
	"Build number (generated by build system)")
set(HR_APP_PRERELEASE TRUE CACHE BOOL
	"Prerelease build (set to FALSE for release builds)")
set(HR_EXTRA_WARNINGS FALSE CACHE BOOL
	"Enable extra compiler warnings")

set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/CMakeModules)

if(MSVC)
	if(MSVC_VERSION EQUAL 1800)
		if(NOT CMAKE_GENERATOR_TOOLSET STREQUAL "CTP_Nov2013")
			message(STATUS "Enabling Visual C++ November 2013 CTP compiler")
			set(CMAKE_GENERATOR_TOOLSET "CTP_Nov2013" CACHE STRING "Platform Toolset" FORCE)
			set(CMAKE_VS_PLATFORM_TOOLSET "CTP_Nov2013" CACHE STRING "Platform Toolset" FORCE)
			message(FATAL_ERROR "Platform toolset configuration updated.
** Please run the Configure step again to apply the changes. **")
		endif()
	endif()
endif()

include(CheckCXXSourceCompiles)
include(CXX11)
include(GNUInstallDirs)
include(cotire)

if(MSVC)
	if(MSVC_VERSION LESS 1800)
		message(FATAL_ERROR "Visual Studio 2013 (aka Visual Studio 12) or later is required.")
	elseif(MSVC_VERSION EQUAL 1800)
		message(STATUS "Enabling Visual C++ November 2013 CTP compiler")

		# Check that the toolset is available.
		if(NOT HAVE_NOV_2013_CTP)
			unset(HAVE_NOV_2013_CTP CACHE)  # Force recheck.
			check_cxx_source_compiles(
				"// Default move ops are only available in the CTP.
				struct TestMove {
					TestMove(TestMove&&) = default;
					TestMove &operator=(TestMove&&) = default;
				};
				int main() { return 0; }" HAVE_NOV_2013_CTP)
			if(NOT HAVE_NOV_2013_CTP)
				message(FATAL_ERROR "The Visual C++ November 2013 CTP compiler is not installed.
The compiler update can be downloaded from:
	http://www.microsoft.com/en-us/download/details.aspx?id=41151")
			endif()
		endif()
	endif()
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
	execute_process(COMMAND ${CMAKE_CXX_COMPILER} --version
		OUTPUT_VARIABLE CLANG_VERSION_OUT)
	string(REGEX MATCH "clang version [0-9]+\\.[0-9]+" CLANG_VERSION_STRING
		"${CLANG_VERSION_OUT}")
	string(REGEX MATCH "[0-9]+\\.[0-9]+" CLANG_VERSION
		"${CLANG_VERSION_STRING}")

	message(STATUS "Clang version: ${CLANG_VERSION}")

	if(CLANG_VERSION VERSION_EQUAL 3.4 OR CLANG VERSION_GREATER 3.4)
		message(WARNING "There are known issues when using Clang 3.4 or later.
For more info: https://github.com/HoverRace/HoverRace/issues/262")
	endif()
endif()

check_for_cxx11_compiler(CXX11_COMPILER)
if(CXX11_COMPILER)
	enable_cxx11()
else()
	message(WARNING "A C++11-capable compiler was not detected, but we'll attempt to build anyway.")
endif()

# Enable use of std::chrono for timestamps for all platforms for now.
set(WITH_CHRONO_TIMESTAMP TRUE)

# Set up the Boost dependency.
# We only need to list the libraries that have libraries;
# we assume that header-only libraries are available without checking.
include(FindBoost)
if(WIN32)
	set(Boost_USE_STATIC_LIBS ON)
else()
	add_compile_options(-DBOOST_ALL_DYN_LINK)
endif()
set(Boost_USE_MULTITHREADED ON)
set(BOOST_MIN_VER 1.54)
find_package(Boost ${BOOST_MIN_VER} REQUIRED COMPONENTS
	filesystem log system thread)
include_directories(${Boost_INCLUDE_DIRS})
link_directories(${Boost_LIBRARY_DIRS})

# Gather the build artifacts into common directories.
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/dist)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

# Use bundled Lua and Luabind from source.
add_subdirectory(external)
include_directories(SYSTEM ${HR_EXTERNAL_INCLUDE_DIRS})

set(ENABLE_NLS TRUE)

if(UNIX)
	include(FindPkgConfig)
	pkg_check_modules(DEPS REQUIRED
		freealut>=1.1
		libcurl>=7.18
		libxdg-basedir>=1.0
		openal>=0.0.8
		sdl2>=2.0
		SDL2_image>=2.0
		SDL2_ttf>=2.0)
	include_directories(SYSTEM ${DEPS_INCLUDE_DIRS})
	link_directories(${DEPS_LIBRARY_DIRS})

	# Find LibYAML.
	include(FindYAML)
	find_package(YAML REQUIRED)
	include_directories(${YAML_INCLUDE_DIR})
	list(APPEND DEPS_LIBRARIES ${YAML_LIBRARIES})

elseif(WIN32)
	# For Win32 builds, we include the bulk of the dependencies.
	# Boost is the exception since it's simply too big.
	set(DEPS_LIBRARIES
		LiteUnzip
		LiteZip
		OpenAL32
		optimized SDL2 debug SDL2D
		optimized SDL2main debug SDL2mainD
		optimized SDL2_image debug SDL2_imageD
		optimized SDL2_ttf debug SDL2_ttfD
		alut
		intl
		optimized libcurl debug libcurlD
		optimized yaml debug yamlD)

	include_directories(
		${CMAKE_SOURCE_DIR}/include
		${CMAKE_SOURCE_DIR}/include/lua)
	link_directories(${CMAKE_SOURCE_DIR}/lib)
endif()

# Generate the initial app config file.
# We only do very basic escaping of the path here.
# In reality, if you have a sufficiently wacky source path, then some of the
# other CMake modules are more likely to fail before even reaching here :)
set(HR_MEDIA_PATH "${CMAKE_SOURCE_DIR}/share")
string(REPLACE "\\" "\\\\" HR_MEDIA_PATH "${HR_MEDIA_PATH}")
string(REPLACE "\"" "\\\"" HR_MEDIA_PATH "${HR_MEDIA_PATH}")
string(REPLACE "\n" "\\\n" HR_MEDIA_PATH "${HR_MEDIA_PATH}")
file(WRITE ${CMAKE_BINARY_DIR}/etc/config.yml
	"app:\n"
	"  mediaPath: \"${HR_MEDIA_PATH}\"\n")

set(CONFIG_HEADER_DIR ${CMAKE_BINARY_DIR}/config)
configure_file(config.in.h ${CONFIG_HEADER_DIR}/hoverrace/hr-config.h
	ESCAPE_QUOTES)
include_directories(SYSTEM ${CONFIG_HEADER_DIR})

add_subdirectory(client)
add_subdirectory(engine)
add_subdirectory(compilers)

